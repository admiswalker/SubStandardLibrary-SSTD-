#pragma once


//-----------------------------------------------------------------------------------------------------------------------------------------------

TEST(encode_decode, base64_encode_c_l){
    std::string str_b64  = "#include \"./sstd/sstd.hpp\".+=ABCD";
    ASSERT_STREQ(sstd::base64_encode((uchar*)str_b64.c_str(), str_b64.size()).c_str(), "I2luY2x1ZGUgIi4vc3N0ZC9zc3RkLmhwcCIuKz1BQkNE");
}
TEST(encode_decode, base64_encode_c){
    std::string str_b64  = "#include \"./sstd/sstd.hpp\".+=ABCD";
    ASSERT_STREQ(sstd::base64_encode(str_b64.c_str()).c_str(), "I2luY2x1ZGUgIi4vc3N0ZC9zc3RkLmhwcCIuKz1BQkNE");
}
TEST(encode_decode, base64_encode_s){
    std::string str_b64  = "#include \"./sstd/sstd.hpp\".+=ABCD";
    ASSERT_STREQ(sstd::base64_encode(str_b64).c_str(), "I2luY2x1ZGUgIi4vc3N0ZC9zc3RkLmhwcCIuKz1BQkNE");
}

//---

TEST(encode_decode, base64_decode_c_l){
    std::string str_b64  = "#include \"./sstd/sstd.hpp\".+=ABCD";
    std::string str_b64e = sstd::base64_encode(str_b64);
    ASSERT_STREQ(sstd::base64_decode((uchar*)str_b64e.c_str(), str_b64e.size()).c_str(), str_b64.c_str());
}
TEST(encode_decode, base64_decode_c){
    std::string str_b64  = "#include \"./sstd/sstd.hpp\".+=ABCD";
    std::string str_b64e = sstd::base64_encode(str_b64);
    ASSERT_STREQ(sstd::base64_decode((uchar*)str_b64e.c_str()).c_str(), str_b64.c_str());
}
TEST(encode_decode, base64_decode_s){
    std::string str_b64  = "#include \"./sstd/sstd.hpp\".+=ABCD";
    std::string str_b64e = sstd::base64_encode(str_b64);
    ASSERT_STREQ(sstd::base64_decode(str_b64e).c_str(), str_b64.c_str());
}

//---

TEST(encode_decode, print_base64_decode_table){
    testing::internal::CaptureStdout();
    sstd::print_base64_decode_table(); // for developers
    std::string s = testing::internal::GetCapturedStdout().c_str();

    std::string s_ans = R"(0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0x3E, 0xFF, 0xFF, 0xFF, 0x3F, 0x34, 0x35, 
0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 
0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 
0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 
0x19, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1A, 0x1B, 0x1C, 
0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 
0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 
0x31, 0x32, 0x33, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
)";
    ASSERT_STREQ(s.c_str(), s_ans.c_str());
}

//-----------------------------------------------------------------------------------------------------------------------------------------------

TEST(encode_decode, url_encode_c_l){
    std::string str_url(256, 0); for(uint i=0; i<str_url.size(); i++){ str_url[i]=i; }
    ASSERT_STREQ(sstd::url_encode(str_url.c_str(), str_url.size()).c_str(), "%00%01%02%03%04%05%06%07%08%09%0A%0B%0C%0D%0E%0F%10%11%12%13%14%15%16%17%18%19%1A%1B%1C%1D%1E%1F%20%21%22%23%24%25%26%27%28%29%2A%2B%2C-.%2F0123456789%3A%3B%3C%3D%3E%3F%40ABCDEFGHIJKLMNOPQRSTUVWXYZ%5B%5C%5D%5E_%60abcdefghijklmnopqrstuvwxyz%7B%7C%7D~%7F%80%81%82%83%84%85%86%87%88%89%8A%8B%8C%8D%8E%8F%90%91%92%93%94%95%96%97%98%99%9A%9B%9C%9D%9E%9F%A0%A1%A2%A3%A4%A5%A6%A7%A8%A9%AA%AB%AC%AD%AE%AF%B0%B1%B2%B3%B4%B5%B6%B7%B8%B9%BA%BB%BC%BD%BE%BF%C0%C1%C2%C3%C4%C5%C6%C7%C8%C9%CA%CB%CC%CD%CE%CF%D0%D1%D2%D3%D4%D5%D6%D7%D8%D9%DA%DB%DC%DD%DE%DF%E0%E1%E2%E3%E4%E5%E6%E7%E8%E9%EA%EB%EC%ED%EE%EF%F0%F1%F2%F3%F4%F5%F6%F7%F8%F9%FA%FB%FC%FD%FE%FF");
}
TEST(encode_decode, url_encode_c){
    std::string str_url(256, 0); for(uint i=0; i<str_url.size(); i++){ str_url[i]=i; }
    ASSERT_STREQ(sstd::url_encode(str_url.c_str()).c_str(), ""); // 先頭が 0 なので、終端だと判断されている。
}
TEST(encode_decode, url_encode_s){
    std::string str_url(256, 0); for(uint i=0; i<str_url.size(); i++){ str_url[i]=i; }
    ASSERT_STREQ(sstd::url_encode(str_url).c_str(), "%00%01%02%03%04%05%06%07%08%09%0A%0B%0C%0D%0E%0F%10%11%12%13%14%15%16%17%18%19%1A%1B%1C%1D%1E%1F%20%21%22%23%24%25%26%27%28%29%2A%2B%2C-.%2F0123456789%3A%3B%3C%3D%3E%3F%40ABCDEFGHIJKLMNOPQRSTUVWXYZ%5B%5C%5D%5E_%60abcdefghijklmnopqrstuvwxyz%7B%7C%7D~%7F%80%81%82%83%84%85%86%87%88%89%8A%8B%8C%8D%8E%8F%90%91%92%93%94%95%96%97%98%99%9A%9B%9C%9D%9E%9F%A0%A1%A2%A3%A4%A5%A6%A7%A8%A9%AA%AB%AC%AD%AE%AF%B0%B1%B2%B3%B4%B5%B6%B7%B8%B9%BA%BB%BC%BD%BE%BF%C0%C1%C2%C3%C4%C5%C6%C7%C8%C9%CA%CB%CC%CD%CE%CF%D0%D1%D2%D3%D4%D5%D6%D7%D8%D9%DA%DB%DC%DD%DE%DF%E0%E1%E2%E3%E4%E5%E6%E7%E8%E9%EA%EB%EC%ED%EE%EF%F0%F1%F2%F3%F4%F5%F6%F7%F8%F9%FA%FB%FC%FD%FE%FF");
}

//---

TEST(encode_decode, url_encode_compare_speed){
    sstd::url_encode_compare_speed(); // for developers
}

//---

TEST(encode_decode, url_dencode_c_l){
    std::string str = "#include \"./sstd/sstd.hpp\".+=ABCD";
    std::string str_url_encoded = sstd::url_encode(str);
    
    ASSERT_STREQ(sstd::url_decode(str_url_encoded.c_str(), str_url_encoded.size()).c_str(), str.c_str());
}
TEST(encode_decode, url_dencode_c){
    std::string str = "#include \"./sstd/sstd.hpp\".+=ABCD";
    std::string str_url_encoded = sstd::url_encode(str);
    
    ASSERT_STREQ(sstd::url_decode(str_url_encoded.c_str()).c_str(), str.c_str());
}
TEST(encode_decode, url_dencode_s){
    std::string str = "#include \"./sstd/sstd.hpp\".+=ABCD";
    std::string str_url_encoded = sstd::url_encode(str);
    
    ASSERT_STREQ(sstd::url_decode(str_url_encoded).c_str(), str.c_str());
}

//---

TEST(encode_decode, print_url_decode_table){
    testing::internal::CaptureStdout();
    sstd::print_url_decode_table(); // for developers
    std::string s = testing::internal::GetCapturedStdout().c_str();

    std::string s_ans = R"( 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFE, 0xFF, 0x00, 0x01,
 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
 0x0F, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0x0A, 0x0B, 0x0C,
 0x0D, 0x0E, 0x0F, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
 0xFE, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
)";
    ASSERT_STREQ(s.c_str(), s_ans.c_str());
}

//-----------------------------------------------------------------------------------------------------------------------------------------------

TEST(encode_decode, utf8_16){

    printf("■ utf8 <-> utf16\n");
    printf("  □ unicode escape (utf16) -> utf16 (binary)\n");
    std::string escaped_utf16 = R"(\u30e6\u30cb\u30b3\u30fc\u30c9)"; // "ユニコード"
//    std::string escaped_utf16 = R"(abcd_\u30e6\u30cb\u30b3\u30fc\u30c9)"; // "abcd_ユニコード" // <- これがバグる。 issue
    std::u16string utf16_bin = sstd::unicodeEscape_decode(escaped_utf16);
    for(uint i=0; i<utf16_bin.size(); i++){ printf("%X\n", utf16_bin[i]); }
    
    printf("  □ utf16 (binary) -> utf8\n");
    std::string utf8 = sstd::utf16_to_utf8(utf16_bin);
    printf("%s\n", utf8.c_str());

    std::u32string utf32_bin = sstd::utf8_to_utf32(utf8);
    std::u16string utf16_bin2 = sstd::utf32_to_utf16(utf32_bin);

    printf("  □ utf16 (binary) -> unicode escape (utf16)\n");
    printf("%s\n", sstd::unicodeEscape_encode(utf16_bin2).c_str());

    sstd::unicodeEscape_compare_speed(); // for developers
    printf("\n");

    printf("  □ make_unicodeEscape_decode_table\n");
    sstd::print_unicodeEscape_decode_table();
    printf("\n");
}

//-----------------------------------------------------------------------------------------------------------------------------------------------
