#include <string.h>

#include <cassert>
#include <string>
#include <vector>

#include "yaml.hpp"

#include "../container/vector/vec_manipulation.hpp"
#include "../definitions/typeDef.h"
#include "../string/strEdit.hpp"
#include "../string/strmatch.hpp"
#include "../print/print.hpp" // for debug


//-----------------------------------------------------------------------------------------------------------------------------------------------
// Abbreviations
//
// - dq: double quotation
// - sq: single quatation

//-----------------------------------------------------------------------------------------------------------------------------------------------
// Overall View of YAML Data Processing

// 1. The user side
//
//    1-1. A user calles sstd::yaml_load() or sstd::yaml_load_all()
//
// 2. The SSTD side
//
//    2-1. Splitting the input string splitted by line concering the YAML processing units.
//
//         YAML processing units examples:
//           ex1) Line breaks enclosed in quotation marks
//             - "a\nb\nc"
//             - 'a\nb\nc'
//           ex2) Line breaks enclosed in brackets
//             - [a,\nb,\nc]
//             - {k:\nv}
// 
//         Following ones are processed later:
//           ex1) Line breaks by YAML multiline notations ('|', '|+', '|-', '>', '>+', '>-')
//             - "k: |\n  line1\n  line2\n  line3\n"
//
//    2-2. Counting up all the required parametars to parse YAML
//
//    2-3. Building up parsed objects of YAML (generated by `sstd::terp::var` object)
// 
// 3. The user side
//
//    3-1. The user get the parsed results of YAML.
// 

//-----------------------------------------------------------------------------------------------------------------------------------------------
// print

#define sstd_print_token_base(rhs)                                      \
    printf("\n");                                                       \
    printf("debug info:\n");                                            \
    printf("    line_num_begin: %d\n", rhs.line_num_begin);             \
    printf("    line_num_end: %d\n", rhs.line_num_end);                 \
    printf("    rawStr: %s\n", rhs.rawStr.c_str());                     \
    printf("command:\n");                                               \
    printf("    type: %d\n", rhs.type);                                 \
    printf("    format: %d\n", rhs.format);                             \
    printf("    list_type_cnt: %d\n", rhs.list_type_cnt);               \
    printf("    hasValue: %s\n", (rhs.hasValue?"ture":"false"));        \
    printf("    hsc_lx: %d\n", rhs.hsc_lx);                             \
    printf("    hsc_hx: %d\n", rhs.hsc_hx);                             \
    printf("    val1: %s\n", rhs.val1.c_str());                         \
    printf("    val2: %s\n", rhs.val2.c_str());                         \
    printf(",\n");

void sstd::print(const sstd_yaml::token& rhs){
    sstd_print_token_base(rhs);
    printf("\n");
}
void sstd::for_printn(const sstd_yaml::token& rhs){ printf(" = "); sstd::print(rhs); }
void sstd::print_for_vT(const sstd_yaml::token& rhs){
    sstd_print_token_base(rhs);
}

#undef sstd_print_token_base

//---

#define sstd_print_command_v2_base(rhs)                         \
    printf("\n");                                               \
    printf("debug info:\n");                                    \
    printf("    line_num_begin: %d\n", rhs.line_num_begin);     \
    printf("    line_num_end: %d\n", rhs.line_num_end);         \
    printf("    rawStr: %s", rhs.rawStr.c_str());               \
    printf("command:\n");                                       \
    printf("    ope: %d\n", rhs.ope);                           \
    printf("    hsc: %d\n", rhs.hsc);                           \
    printf("    type: %d\n", rhs.type);                         \
    printf("    format: %d\n", rhs.format);                     \
    printf("    val: %s\n", rhs.val.c_str());                   \
    printf(",\n");

void sstd::print(const sstd_yaml::command_v2& rhs){
    sstd_print_command_v2_base(rhs);
    printf("\n");
}
void sstd::for_printn(const sstd_yaml::command_v2& rhs){ printf(" = "); sstd::print(rhs); }
void sstd::print_for_vT(const sstd_yaml::command_v2& rhs){
    sstd_print_command_v2_base(rhs);
}

#undef sstd_print_command_v2_base

//-----------------------------------------------------------------------------------------------------------------------------------------------

std::string _extract_quotes_value(const std::string& str){
    std::string tmp;
    std::string ret;

    // Space conversion
    //   - example 1: "a b c " -> "a b c "
    //   - example 2: "a  \n  b  \n  c  " -> "a\nb\nc  "
    for(uint i=0; i<str.size(); ++i){
        if(str[i]=='\n'){
            sstd::rstrip_ow(tmp);
            tmp += str[i];
            ++i; while(i<str.size() && str[i]==' '){ ++i; } --i;
        }else{
            tmp += str[i];
        }
    }
    
    // conversion
    //   - example 1: "a\nb\nc  " -> "a b c  "
    bool escape = false;
    uint new_line_cnt=0;
    for(uint i=0; i<tmp.size(); ++i){
        if(tmp[i]=='\\'){
            escape=true;
            continue;
        }
//        if(escape){ // when using a escaped notation rule
//            switch(tmp[i]){
//            case '"': { ret += '\\'; } break;
//            default: break;
//            }
//        }
        
        if(tmp[i]=='\n'){ ++new_line_cnt; continue; }
        
        if(new_line_cnt==1){
            if(!escape){
                ret += " ";
            }
        }else if(new_line_cnt>=2){
//            for(uint i_t=0; i_t<new_line_cnt-1; ++i_t){ ret += "\\n"; } // when using a escaped notation rule
            for(uint i_t=0; i_t<new_line_cnt-1; ++i_t){ ret += '\n'; }
        }
        
        ret += tmp[i];
        
        new_line_cnt=0;
        escape = false;
    }
    
    return ret;
}

//-----------------------------------------------------------------------------------------------------------------------------------------------

std::string _rm_comment(const std::string& s){
    std::vector<std::string> v = sstd::split(s, '#');
    if(v.size()==0){ return std::string(); }
    return sstd::rstrip(v[0]);
}

void _rm_colon(std::string& s){
    if(s.size()>=1){
        s.pop_back();
    }
    return;
}
std::string _rm_hyphen(std::string s){
    uint i=0;
    for(; i<s.size(); ++i){
        if(s[i]==' '||s[i]=='-'){ continue; }
        break;
    }
    return &s[i];
}

//---

bool _is_hash(bool& ret, const std::string& s){
    ret = false;
    std::string ret_s;
    if(!sstd::extract_unquoted(ret_s, s)){ sstd::pdbg_err("quate is not closed\n"); return false; }
    ret = sstd::strIn(": ", ret_s) || (s.size()>=1 && s[s.size()-1]==':');
    return true;
}
std::string _extract_hash_value(const std::string& s){
    for(uint i=0; i<s.size()-1; ++i){
        if(s[i]==':' && s[i+1]==' ' && i+2<s.size()){ return std::string(&s[i+2]); }
    }
    
    return "";
}

//---

uint _head_space_or_hyphen_count(const std::string& s){
    uint c=0;
    for(uint i=0; i<s.size(); ++i){
        if(s[i]==' ' || s[i]=='-'){ ++c; continue; }
        break;
    }
    return c;
}
uint _head_space_count(const std::string& s){
    uint c=0;
    for(uint i=0; i<s.size(); ++i){
        if(s[i]==' '){ ++c; continue; }
        break;
    }
    return c;
}
bool _hsc_hx(uint& ret, const std::string& s){
    bool is_h;
    if(!_is_hash(is_h, s)){ sstd::pdbg_err("quate is not closed\n"); return false; }
    
    if(is_h){ ret = _head_space_or_hyphen_count(s); return true;
    }  else { ret = _head_space_count(s);           return true;
    }
}
void _hsc_lx(uint& ret, const std::string& s){
    ret = _head_space_count(s);
    return;
}

//---

void _print(const struct sstd_yaml::command& cmd){ // for debug
    printf("hsc_lx: %d\n",           cmd.hsc_lx                            );
    printf("hsc_hx: %d\n",           cmd.hsc_hx                            );
    printf("type: %d\n",             cmd.type                              );
    printf("format: %d\n",           cmd.format                            );
    printf("val1_use_quotes: %s\n", (cmd.val1_use_quotes ? "true":"false") );
    printf("val2_use_quotes: %s\n", (cmd.val2_use_quotes ? "true":"false") );
    printf("val1: %s\n",             cmd.val1.c_str()                      );
    printf("val2: %s\n",             cmd.val2.c_str()                      );
    printf("lineNum: %d\n",          cmd.lineNum                           );
    printf("rawStr: %s\n",           cmd.rawStr.c_str()                    );
    printf("\n");
}
void _print(const std::vector<struct sstd_yaml::command>& v_cmd){ // for debug
    for(uint i=0; i<v_cmd.size(); ++i){
        _print(v_cmd[i]);
    }
}

//---

bool sstd_yaml::_data_type_and_format(uint& type, uint& format, uint& list_type_cnt, std::string s){
    type   = sstd_yaml::num_str;
    format = sstd_yaml::num_block_style_base;
    list_type_cnt = 0;

    std::vector<std::string> v;
    if(!sstd::split_quotes(v, s)){ sstd::pdbg_err("quate is not closed\n"); return false; }
//    sstd::printn(v);
    
    bool is_list = false;
    bool is_hash = false;

    for(uint i=0; i<v.size(); ++i){
        uint size = v[i].size();
        
        if(size>=1 && v[i][   0  ]=='['){ format=sstd_yaml::num_flow_style_base; }
        if(size>=1 && v[i][   0  ]=='{'){ format=sstd_yaml::num_flow_style_base; }
        if(size==1 && v[i][   0  ]=='-'){ is_list=true; ++list_type_cnt; }
        if(size>=1 && v[i][size-1]==':'){ if(format!=sstd_yaml::num_flow_style_base){ is_hash=true; } }
    }
    if(is_list){ type += sstd_yaml::num_list; }
    if(is_hash){ type += sstd_yaml::num_hash; }
    
    return true;
}
bool _split_hash(std::vector<std::string>& ret_v, std::string s){
    if(s.size()>=1 && s[s.size()-1]==':'){ s.pop_back(); ret_v.push_back(s); return true; }
    return sstd::split_quotes(ret_v, s, ": ");
}
bool _get_value(bool& ret_val1_use_quotes, bool& ret_val2_use_quotes, std::string& ret_val1, std::string& ret_val2, std::string s, uint typeNum, uint format){
    ret_val1_use_quotes=false;
    ret_val2_use_quotes=false;
    ret_val1.clear();
    ret_val2.clear();
    bool dq, sq;

    // switch(v_cmd[i].format + v_cmd[i].type){ // 730 行目的なかんじ (<-) に修正したい
    if(format==sstd_yaml::num_block_style_base){
        switch(typeNum){
        case sstd_yaml::num_str:  {
            ret_val1 = _extract_quotes_value(sstd::strip_quotes(sq, dq, s));
            ret_val1_use_quotes = ( dq || sq );
        } break;
        case sstd_yaml::num_list: {
            ret_val1 = _extract_quotes_value(sstd::strip_quotes(sq, dq, _rm_hyphen(s)));
            ret_val1_use_quotes = ( dq || sq );
        } break;
        case sstd_yaml::num_hash:
        case sstd_yaml::num_list_and_hash: {
            std::vector<std::string> v;
            if(!_split_hash(v, s)){ sstd::pdbg_err("single quatation or double quatation is not closed\n"); return false; }
            //if(v.size()==0){ sstd::pdbg_err("Unexpected data size.\n"); return false; }
            if(v.size()>=1){ ret_val1 = _extract_quotes_value(sstd::strip_quotes(sq, dq, _rm_hyphen(v[0]))); ret_val1_use_quotes = ( sq || dq ); }
            if(v.size()>=2){ ret_val2 = _extract_quotes_value(sstd::strip_quotes(sq, dq,            v[1] )); ret_val2_use_quotes = ( sq || dq ); }
            if(v.size()>=3){ sstd::pdbg("Unexptected split by ':'."); return false; }
        } break;
        default: { sstd::pdbg_err("Unexpected typeNum\n"); return false; } break;
        }
        
    }else if(format==sstd_yaml::num_flow_style_base){
        switch(typeNum){
        case sstd_yaml::num_str:  {
            ret_val1 = _extract_quotes_value(sstd::strip_quotes(sq, dq, s));
            ret_val1_use_quotes = ( dq || sq );
        } break;
        case sstd_yaml::num_list:
        case sstd_yaml::num_hash:
        case sstd_yaml::num_list_and_hash: {
            ret_val1 = _extract_quotes_value(sstd::strip_quotes(sq, dq, _rm_hyphen(s)));
            ret_val1_use_quotes = ( dq || sq );
        } break;
        default: { sstd::pdbg_err("Unexpected typeNum\n"); return false; } break;
        }
        
    }else{
        sstd::pdbg_err("Unexpected data type\n"); return false;
    }
    
    return true;
}

bool _get_multi_line_str(std::string& ret, const uint hsc_prev, const std::string& opt, int indent_width, const std::vector<std::string>& ls, uint& i){
    std::vector<std::string> v_tmp;

    char separator='\n';
    //if(sstd::charIn('|', opt)){ separator = '\n'; }
    if(sstd::charIn('>', opt)){ separator =  ' '; }
//    if(indent_width == hsc_prev){ separator = '\n'; }
    
    for(; i<ls.size(); ++i){
        std::string s;
        s = ls[i];
        s = _rm_comment(s); // s = _rm_comment_quotes(s); に置き換える
        if(s=="..."){ --i; return true; } // detect end marker
        
        uint type=sstd_yaml::num_null, format=sstd_yaml::num_block_style_base, type_cnt=0; if(!sstd_yaml::_data_type_and_format(type, format, type_cnt, s)){ return false; }
        if(type==sstd_yaml::num_str){
            if(indent_width>=0 && s.size()>0){
                uint hsc = _head_space_count(s);
                
                if(hsc+1 <= (hsc_prev + indent_width)){ sstd::pdbg_err("indent indecation is too large.\n"); return false; }

                if(hsc_prev + indent_width == hsc){ // for "- >[Num]", "- >[Num]"
                    s = sstd::strip(s);
                }else{
                    s = sstd::rstrip(s);
                    if(indent_width < (int)s.size()){
                        separator = '\n';
                        s = &s[hsc_prev+indent_width];
                    }
                }
            }else{
                s = sstd::strip(s);
            }
            v_tmp.push_back(s);
        }else{
            --i;
            break;
        }
    }

    if      (opt=="|"  || opt==">" ){
        sstd::rmEmpty_r_ow(v_tmp);
        ret = sstd::join(v_tmp, separator);
        ret += "\n";
    }else if(opt=="|-" || opt==">-"){
        sstd::rmEmpty_r_ow(v_tmp);
        ret = sstd::join(v_tmp, separator);
    }else if(opt=="|+" || opt==">+"){
        uint cnt = sstd::cntEmpty_r(v_tmp) + 1;
        sstd::rmEmpty_r_ow(v_tmp);
        ret = sstd::join(v_tmp, separator) + std::string(cnt, '\n');
    }else{
        sstd::pdbg_err("Unexpected case\n"); return false;
    }

    return true;
}
bool _check_val_and_overwrite_multi_line_str(std::string& val_rw, const uint hsc_prev, const std::vector<std::string>& ls, uint& i){
    int indent_width = -1;

    if      (val_rw.starts_with("|-") || val_rw.starts_with(">-") ||    // case: "- |-123", "- >-123", "hash-key: |-123" or "hash-key: >-123"
             val_rw.starts_with("|+") || val_rw.starts_with(">+")    ){ // case: "- |+123", "- >+123", "hash-key: |+123" or "hash-key: >+123"
        ++i;
        std::string opt; opt += val_rw[0]; opt += val_rw[1];
        if(val_rw.size()>=3){
            indent_width = std::stoi(&val_rw[2]);
        }else{
            indent_width = _head_space_count(ls[i]);
        }
        
        if(!_get_multi_line_str(val_rw, hsc_prev, opt, indent_width, ls, i)){ return false; }
        
    }else if(val_rw.starts_with("|" ) || val_rw.starts_with(">" )){ // case: "- |123",  "- >123",  "hash-key: |123"  or "hash-key: >123"
        ++i;
        std::string opt; opt += val_rw[0];
        if(val_rw.size()>=2){
            indent_width = std::stoi(&val_rw[1]);
       }else{
            indent_width = _head_space_count(ls[i]);
        }
        
        if(!_get_multi_line_str(val_rw, hsc_prev, opt, indent_width, ls, i)){ return false; }
        
    }

    return true;
}

//---

uint sstd_lcount(const char* str, char X){
    uint ret_cnt=0;
    for(uint i=0; str[i]!='\0'; ++i){
        if(str[i]!=X){ break; }
        ++ret_cnt;
    }
    return ret_cnt;
}
uint sstd_lcount(const std::string& str, char X){ return sstd_lcount(str.c_str(), X); }

//---

std::string               sstd_lstrip_base   (const uchar* str, const uint len, const uchar* stripList, const uint sLen){
    uint r=0;
    if(len * sLen <= 256){
        for(; r<len; ++r){
            bool TF_continue=false;
            for(uint si=0; si<sLen; ++si){
                if(str[r]==stripList[si]){ TF_continue=true; break; }
            }
            if(!TF_continue){ break; }
        }
    }else{
        bool sTbl[256]={false};
        for(uint si=0; si<sLen; ++si){ sTbl[ (uchar)stripList[si] ] = true; }
        
        for(; r<len; ++r){
            if(!sTbl[ (uchar)str[r] ]){ break; }
        }
    }
    return std::string((const char*)&str[r]);
}
std::string               sstd_rstrip_base   (const uchar* str, const uint len, const uchar* stripList, const uint sLen){
    int r=len-1;
    if(len * sLen <= 256){
        for(; r>=0; --r){
            bool TF_continue=false;
            for(uint si=0; si<sLen; ++si){
                if(str[r]==stripList[si]){ TF_continue=true; break; }
            }
            if(!TF_continue){ break; }
        }
    }else{
        bool sTbl[256]={false};
        for(uint si=0; si<sLen; ++si){ sTbl[ (uchar)stripList[si] ] = true; }
        
        for(; r>=0; --r){
            if(!sTbl[ (uchar)str[r] ]){ break; }
        }
    }
    return std::string((const char*)str, r+1);
}
std::string               sstd_strip   (const std::string& str, const char* pStripList){
    std::string ret = sstd_lstrip_base((const uchar*)str.c_str(), str.size(), (const uchar*)pStripList, strlen(pStripList));
    return            sstd_rstrip_base((const uchar*)ret.c_str(), ret.size(), (const uchar*)pStripList, strlen(pStripList));
}
std::string               sstd_strip   (const std::string& str, const std::string& stripList){
    std::string ret = sstd_lstrip_base((const uchar*)str.c_str(), str.size(), (const uchar*)stripList.c_str(), stripList.size());
    return            sstd_rstrip_base((const uchar*)ret.c_str(), ret.size(), (const uchar*)stripList.c_str(), stripList.size());
}

//std::string               sstd_stripAll   (const        char* str, const        char* stripList);
//std::string               sstd_stripAll   (const std::string& str, const        char* stripList);
//std::string               sstd_stripAll   (const        char* str, const std::string& stripList);
//std::string               sstd_stripAll   (const std::string& str, const std::string& stripList);

//void                      sstd_stripAll_ow(      std::string& str, const        char* stripList);
//void                      sstd_stripAll_ow(      std::string& str, const std::string& stripList);

//---

std::string _join_mult_line(const std::vector<std::string>& v, const bool ret_pipeSymbol, const bool ret_greaterThanSymbol){
    std::string ret;
    if(v.size()==0){ return ret; }
    
    std::vector<std::string> v_delimiter;
    if(ret_pipeSymbol){
        // '|'
        v_delimiter = std::vector<std::string>(v.size()-1, std::string("\n"));
        
    }else if(ret_greaterThanSymbol){
        // '>'
        v_delimiter = std::vector<std::string>(v.size()-1, std::string(" "));
        
        uint i = 0;
        uint hsc = sstd_lcount(v[i], ' '); // hsc: head space count
        if(hsc!=0){ v_delimiter[i] = "\n"; }
        ++i;
        for(; i<v.size()-1; ++i){
            hsc = sstd_lcount(v[i], ' '); // hsc: head space count
            if(hsc!=0){
                v_delimiter[i-1] = "\n";
                v_delimiter[i  ] = "\n";
            }
        }
    }else{
        sstd::pdbg_err("The multiple line needs to denoted by '|' or '>'.\n");
    }
    
    // join
    ret += v[0];
    for(uint i=1; i<v.size(); ++i){
        ret += v_delimiter[i-1] + v[i];
    }

    return ret;
}

//---

bool _parse_mult_line_opt(bool& ret_pipeSymbol, bool& ret_greaterThanSymbol, bool& ret_plusSymbol, bool& ret_minusSymbol, bool& ret_hasHsc, uint& ret_hsc, const std::string& opt){
    // input examples:
    //     "|+123", "|-123", "|123+", "|123-",
    //     ">+123", ">-123", ">123+", ">123-".
    
    ret_pipeSymbol=false;
    ret_greaterThanSymbol=false;
    ret_plusSymbol=false;
    ret_minusSymbol=false;
    ret_hasHsc=false;
    ret_hsc=0;
    for(uint i=0; i<opt.size(); ++i){
        if(opt[i]=='|'){ if(ret_pipeSymbol       ){sstd::pdbg_err("Duplicated '|'.\n");return false;} ret_pipeSymbol       =true; continue; }
        if(opt[i]=='>'){ if(ret_greaterThanSymbol){sstd::pdbg_err("Duplicated '>'.\n");return false;} ret_greaterThanSymbol=true; continue; }
        if(opt[i]=='+'){ if(ret_plusSymbol       ){sstd::pdbg_err("Duplicated '+'.\n");return false;} ret_plusSymbol       =true; continue; }
        if(opt[i]=='-'){ if(ret_minusSymbol      ){sstd::pdbg_err("Duplicated '-'.\n");return false;} ret_minusSymbol      =true; continue; }
    }
    std::string sNum = sstd_strip(opt, "|>+-");
    if(sNum.size()==0){ return true; }
    if(!sstd::isNum(sNum)){ sstd::pdbg_err("Not numer.\n"); return false; }
    ret_hasHsc=true;
    ret_hsc = std::stoul(sNum);
    
    return true;
}

//---

bool sstd_yaml::_format_mult_line_str(std::string& ret, const std::string& str, const uint hsc_base_yaml){
    ret.clear();
    std::vector<std::string> v_str = sstd::splitByLine(str+"\n"); // "\n" modify the num of split sections
    std::vector<std::string> v_tmp;
    
    if(v_str.size()<2){ return true; }
    bool ret_pipeSymbol=false, ret_greaterThanSymbol=false;
    bool ret_plusSymbol=false, ret_minusSymbol=false;
    bool ret_hasHsc=false; uint ret_user_requested_hsc=0;
    std::string opt=v_str[0];
    if(!_parse_mult_line_opt(ret_pipeSymbol, ret_greaterThanSymbol, ret_plusSymbol, ret_minusSymbol, ret_hasHsc, ret_user_requested_hsc, opt)){ sstd::pdbg_err("_parse_mult_line_opt() is failed.\n"); return false; }
    if((!ret_pipeSymbol) && (!ret_greaterThanSymbol)){ sstd::pdbg_err("The multiple line needs to denoted by '|' or '>'.\n"); return false; }
    
    const uint hsc_bash_1st_line=sstd_lcount(v_str[1], ' '); // hsc: head space count
    if(hsc_bash_1st_line<=hsc_base_yaml){
        // Error case.
        // - |
        // a  <- error (Required more than 1 hsc)
        sstd::pdbg_err("The space count of multiple line indent is invalid.\n");
        return false;
    }

    uint hsc_bash=hsc_bash_1st_line;
    if(ret_hasHsc){
        if(ret_user_requested_hsc==0){ sstd::pdbg_err("The user requested indent can not be 0.\n"); return false; }
        if(ret_user_requested_hsc>hsc_bash_1st_line){
            // Error case.
            // - |9
            //   a  <- error (Required more than 10 hsc)
            sstd::pdbg_err("The user requested indent size is too large.\n");
            return false;
        }
        hsc_bash=ret_user_requested_hsc;
    }
    
    for(uint i=1; i<v_str.size(); ++i){
        std::string s=v_str[i];
        std::string tmp;
        uint hsc = sstd_lcount(s, ' '); // hsc: head space count
        bool have_str_except_space = (hsc!=s.size());

        if(have_str_except_space && hsc<hsc_bash){
            // Error case.
            // - |
            //   a
            // b    <- error (Required more than 2 hsc)
            //   c
            sstd::pdbg_err("The space count of multiple line indent is invalid.\n");
            return false;
        }
        
        if(s.size()>=hsc_bash){
            tmp += (char*)&v_str[i][hsc_bash];
        }

        v_tmp.push_back(tmp);
    }
    
    if((!ret_plusSymbol) && (!ret_minusSymbol)){
        // "|N" or ">N"
        
        int cnt = (int)sstd::cntEmpty_r(v_tmp);
        sstd::rmEmpty_r_ow(v_tmp);
        ret = _join_mult_line(v_tmp, ret_pipeSymbol, ret_greaterThanSymbol) + std::string(std::min(1,cnt), '\n');
        
    }else if(ret_minusSymbol){
        // "|-N" or ">-N"
        
        sstd::rmEmpty_r_ow(v_tmp);
        ret = _join_mult_line(v_tmp, ret_pipeSymbol, ret_greaterThanSymbol);
        
    }else if(ret_plusSymbol){
        // "|+N" or ">+N"
        
        int cnt = (int)sstd::cntEmpty_r(v_tmp);
        sstd::rmEmpty_r_ow(v_tmp);
        ret = _join_mult_line(v_tmp, ret_pipeSymbol, ret_greaterThanSymbol) + std::string(cnt, '\n');
        
    }else{
        sstd::pdbg_err("Unexpected case\n"); return false;
    }
    
    return true;
}

bool _parse_yaml(std::vector<struct sstd_yaml::command>& ret_vCmd, const std::vector<std::string>& ls, const uint base_idx){ // token ベースに書き換えたら消す
    
    for(uint i=0; i<ls.size(); ++i){
        std::string raw, s;
        raw = ls[i];
        s = _rm_comment(raw); // s = _rm_comment_quotes(s); に置き換える
        if(s.size()==0){ continue; }
        if(s=="..."){ return true; } // detect end marker
        uint type=sstd_yaml::num_null, format=sstd_yaml::num_block_style_base, type_cnt=0; if(!sstd_yaml::_data_type_and_format(type, format, type_cnt, s)){ return false; }
        uint hsc_lx=0;     _hsc_lx(hsc_lx, s);
        uint hsc_hx=0; if(!_hsc_hx(hsc_hx, s)){ sstd::pdbg_err("quate is not closed\n"); return false; }
        
        bool val1_use_quotes, val2_use_quotes;
        std::string val1, val2;
        if(!_get_value(val1_use_quotes, val2_use_quotes, val1, val2, s, type, format)){ return false; }
        //if      (format==sstd_yaml::num_block_style_base){ if(!_get_value(val1_use_quotes, val2_use_quotes, val1, val2, s, type)){ return false; }
        //}else if(format==sstd_yaml::num_flow_style_base ){ val1 = s;
        //}else                            { sstd::pdbg_err("Unexpected data type\n"); return false; }
        
        // for multiple line string
        if(!_check_val_and_overwrite_multi_line_str(val1, hsc_lx, ls, i)){ sstd::pdbg_err("reading multiline is failed.\n"); return false; } // for list (val1=="|0123" or val1=="|-0123" val1=="|+0123")
        if(!_check_val_and_overwrite_multi_line_str(val2, hsc_hx, ls, i)){ sstd::pdbg_err("reading multiline is failed.\n"); return false; } // for hash (val2=="|0123" or val2=="|-0123" val2=="|+0123")

        struct sstd_yaml::command c;
        switch(type){
        case sstd_yaml::num_str: {
            c.hsc_lx          = hsc_lx;
            c.hsc_hx          = hsc_hx;
            c.type            = sstd_yaml::num_str;
            c.format          = format;
            c.val1_use_quotes = val1_use_quotes;
            c.val2_use_quotes = val2_use_quotes;
            c.val1            = val1;
            //c.val2           = val2;
            c.lineNum         = base_idx + i; // debug info
            c.rawStr          = raw;          // debug info
            
            ret_vCmd.push_back(c);
        } break;
        case sstd_yaml::num_list: {
            for(uint ti=0; ti<type_cnt-1; ++ti){ // for multiple list. ex: "- - a".
                c.hsc_lx          = hsc_lx + 2*ti;
                c.hsc_hx          = hsc_hx + 2*ti;
                c.type            = sstd_yaml::num_list;
                c.format          = format;
                c.val1_use_quotes = false;
                c.val2_use_quotes = false;
                //c.val1           = val1;
                //c.val2           = val2;
                c.lineNum         = base_idx + i; // debug info
                c.rawStr          = raw;          // debug info
            
                ret_vCmd.push_back(c);
            }
            
            c.hsc_lx          = hsc_lx + 2*(type_cnt-1);
            c.hsc_hx          = hsc_hx + 2*(type_cnt-1);
            c.type            = sstd_yaml::num_list;
            c.format          = format;
            c.val1_use_quotes = val1_use_quotes;
            c.val2_use_quotes = val2_use_quotes;
            c.val1            = val1;
            //c.val2           = val2;
            c.lineNum         = base_idx + i; // debug info
            c.rawStr          = raw;          // debug info
            
            ret_vCmd.push_back(c);
        } break;
        case sstd_yaml::num_hash: {
            c.hsc_lx          = hsc_lx;
            c.hsc_hx          = hsc_hx;
            c.type            = sstd_yaml::num_hash;
            c.format          = format;
            c.val1_use_quotes = val1_use_quotes;
            c.val2_use_quotes = val2_use_quotes;
            c.val1            = val1; // key
            c.val2            = val2; // value
            c.lineNum         = base_idx + i; // debug info
            c.rawStr          = raw;          // debug info
            
            ret_vCmd.push_back(c);
        } break;
        case sstd_yaml::num_list_and_hash:{
            for(uint ti=0; ti<type_cnt-1; ++ti){ // for multiple list-hash. ex: "- - k1: v1".
                c.hsc_lx          = hsc_lx + 2*ti;
                c.hsc_hx          = hsc_hx + 2*ti;
                c.type            = sstd_yaml::num_list;
                c.format          = format;
                c.val1_use_quotes = false;
                c.val2_use_quotes = false;
                //c.val1           = "";
                //c.val2           = "";
                c.lineNum         = base_idx + i; // debug info
                c.rawStr          = raw;          // debug info
                
                ret_vCmd.push_back(c);
            }
            
            c.hsc_lx          = hsc_lx + 2*(type_cnt-1);
            c.hsc_hx          = hsc_hx + 2*(type_cnt-1);
            c.type            = sstd_yaml::num_list_and_hash;
            c.format          = format;
            c.val1_use_quotes = false;
            c.val2_use_quotes = false;
            //c.val1           = "";
            //c.val2           = "";
            c.lineNum         = base_idx + i; // debug info
            c.rawStr          = raw;          // debug info
            
            ret_vCmd.push_back(c);
            
            c.hsc_lx          = hsc_lx + 2*(type_cnt-1);
            c.hsc_hx          = hsc_hx + 2*(type_cnt-1);
            c.type            = sstd_yaml::num_hash;
            c.format          = format;
            c.val1_use_quotes = val1_use_quotes;
            c.val2_use_quotes = val2_use_quotes;
            c.val1            = val1; // key
            c.val2            = val2; // value
            c.lineNum         = base_idx + i; // debug info
            c.rawStr          = raw;          // debug info
            
            ret_vCmd.push_back(c);
        } break;
        default: { sstd::pdbg_err("Unexpected data type\n"); return false; } break;
        };
    }
    
    return true;
}
bool sstd_yaml::_token2cmd(std::vector<struct sstd_yaml::command_v2>& ret_vCmd, const std::vector<sstd_yaml::token>& v_token){
    
    for(uint i=0; i<v_token.size(); ++i){
        const sstd_yaml::token& t = v_token[i];
        
//        printf("------\n");
//        sstd::printn(i);
//        sstd::printn(t);

        // Construct alloc() or assign() command
        struct sstd_yaml::command_v2 c;
        switch(t.type){
        case sstd_yaml::num_str: {
            // --- debug info ---
            c.line_num_begin  = t.line_num_begin;
            c.line_num_end    = t.line_num_end;
            c.rawStr          = t.rawStr;
            // --- construct info ---
            c.ope             = sstd_yaml::ope_assign;
            c.hsc             = t.hsc_hx; // t.hsc_lx
            c.type            = sstd_yaml::num_str;
            c.format          = t.format;
            c.val             = t.val1; // t.val2;
            ret_vCmd.push_back(c);
        } break;
        case sstd_yaml::num_list: {
            for(uint ti=0; ti<t.list_type_cnt; ++ti){ // for multiple list. ex: "- - a".
                // --- debug info ---
                c.line_num_begin  = t.line_num_begin;
                c.line_num_end    = t.line_num_end;
                c.rawStr          = t.rawStr;
                // --- construct info ---
                c.ope             = sstd_yaml::ope_alloc;
                c.hsc             = t.hsc_lx + 2*ti; // t.hsc_hx
                c.type            = sstd_yaml::num_list;
                //c.format          = t.format;
                //c.val             = t.val1; // t.val2;
                ret_vCmd.push_back(c);
            }

            if(t.hasValue){ // check the value is NOT NULL
                // --- debug info ---
                c.line_num_begin  = t.line_num_begin;
                c.line_num_end    = t.line_num_end;
                c.rawStr          = t.rawStr;
                // --- construct info ---
                c.ope             = sstd_yaml::ope_assign;
                c.hsc             = t.hsc_hx + 2*(t.list_type_cnt-1); // t.hsc_lx + 2*(t.list_type_cnt-1);
                c.type            = sstd_yaml::num_str;
                c.format          = t.format;
                c.val             = t.val1; // t.val2;
                ret_vCmd.push_back(c);
            }
        } break;
        case sstd_yaml::num_hash: {
            // --- debug info ---
            c.line_num_begin  = t.line_num_begin;
            c.line_num_end    = t.line_num_end;
            c.rawStr          = t.rawStr;
            // --- construct info ---
            c.ope             = sstd_yaml::ope_alloc;
            c.hsc             = t.hsc_hx; // t.hsc_lx
            c.type            = sstd_yaml::num_hash;
            //c.format          = t.format;
            c.val             = t.val1; // t.val2; // key
            ret_vCmd.push_back(c);
            
            if(t.hasValue){ // check the value is NOT NULL
                // --- debug info ---
                c.line_num_begin  = t.line_num_begin;
                c.line_num_end    = t.line_num_end;
                c.rawStr          = t.rawStr;
                // --- construct info ---
                c.ope             = sstd_yaml::ope_assign;
                c.hsc             = t.hsc_hx + 2; // t.hsc_lx;
                c.type            = sstd_yaml::num_str;
                c.format          = t.format;
                c.val             = t.val2; // t.val1; // value
                ret_vCmd.push_back(c);
            }
        } break;
        case sstd_yaml::num_list_and_hash:{
            for(uint ti=0; ti<t.list_type_cnt; ++ti){ // for multiple list-hash. ex: "- - k1: v1".
                // --- debug info ---
                c.line_num_begin  = t.line_num_begin;
                c.line_num_end    = t.line_num_end;
                c.rawStr          = t.rawStr;
                // --- construct info ---
                c.ope             = sstd_yaml::ope_alloc;
                c.hsc             = t.hsc_lx + 2*ti; // t.hsc_hx + 2*ti
                c.type            = sstd_yaml::num_list;
                //c.format          = t.format;
                //c.val             = t.val1; // t.val2;
                ret_vCmd.push_back(c);
            }

            {
                // construction of stack() command
                
                // --- debug info ---
                c.line_num_begin  = t.line_num_begin;
                c.line_num_end    = t.line_num_end;
                c.rawStr          = t.rawStr;
                // --- construct info ---
                c.ope             = sstd_yaml::ope_stack;
                c.hsc             = t.hsc_hx + 2*(t.list_type_cnt-1); // hsc_lx + 2*(type_cnt-1)
                
                ret_vCmd.push_back(c);
            }
            
            // --- debug info ---
            c.line_num_begin  = t.line_num_begin;
            c.line_num_end    = t.line_num_end;
            c.rawStr          = t.rawStr;
            // --- construct info ---
            c.ope             = sstd_yaml::ope_alloc;
            c.hsc             = t.hsc_hx + 2*(t.list_type_cnt-1); // hsc_lx + 2*(type_cnt-1)
            c.type            = sstd_yaml::num_hash;
            //c.format          = t.format;
            c.val             = t.val1; // t.val2; // key
            ret_vCmd.push_back(c);
            
            if(t.hasValue){ // check the value is NOT NULL
                // --- debug info ---
                c.line_num_begin  = t.line_num_begin;
                c.line_num_end    = t.line_num_end;
                c.rawStr          = t.rawStr;
                // --- construct info ---
                c.ope             = sstd_yaml::ope_assign;
                c.hsc             = t.hsc_hx + 2; // t.hsc_lx;
                c.type            = sstd_yaml::num_str;
                c.format          = t.format;
                c.val             = t.val2; // t.val1; // value
                ret_vCmd.push_back(c);
            }
        } break;
        default: { sstd::pdbg_err("Unexpected data type\n"); return false; } break;
        };

        
        // construction of stack() command
        if( !t.hasValue && (t.type==sstd_yaml::num_list || t.type==sstd_yaml::num_hash || t.type==sstd_yaml::num_list_and_hash )){
            uint hsc_curr = c.hsc;
            uint hsc_next = 0;

            // Checking the Next if is Not end of the v_token. (Checking the v_token[i+1] is NOT Null).
            if( !(i+1<v_token.size()) ){
                // Case of "i" is the last token
                
                // If sstd_yaml::_token2cmd() did NOT append the pop() command,
                // anaway all the cmd2yaml() process is already finished.
                continue;
            }
            const sstd_yaml::token& t_nx = v_token[i+1]; // _nx: next
            
            switch(t_nx.type){
                //case sstd_yaml::num_str:           { hsc_next = t_nx.hsc_hx;                            } break;
            case sstd_yaml::num_str:           { continue; } break;
            case sstd_yaml::num_list:          { hsc_next = t_nx.hsc_lx + 2*(t_nx.list_type_cnt-1); } break;
            case sstd_yaml::num_hash:          { hsc_next = t_nx.hsc_hx;                            } break;
            case sstd_yaml::num_list_and_hash: { hsc_next = t_nx.hsc_lx + 2*(t_nx.list_type_cnt-1); } break; // works as a list
            default: { sstd::pdbg_err("Unexpected data type\n"); return false; } break;
            };

            // Table. stack() conditions
            //
            // ┌───┬───────────────────┬───────────────────────────────────────────────────────────┐
            // │   │                   │ hsc_current                                               │
            // ├───┼───────────────────┼───────────────────┬───────────────────┬───────────────────┤
            // │   │                   │                   │                   │ list_and_hash     │
            // │   │                   │ list              │ hash              │ (works as a hash) │
            // ├───┼───────────────────┼───────────────────┼───────────────────┼───────────────────┤
            // │ h │ list              │ >                 │ >=                │ >=                │
            // │ s │                   │                   │                   │                   │
            // │ c ├───────────────────┼───────────────────┼───────────────────┼───────────────────┤
            // │ _ │ list_and_hash     │ >                 │ >=                │ >=                │
            // │ n │ (works as a list) │                   │                   │                   │
            // │ e ├───────────────────┼───────────────────┼───────────────────┼───────────────────┤
            // │ x │ hash              │ >                 │ >                 │ >                 │
            // │ t │                   │                   │                   │                   │
            // └───┴───────────────────┴───────────────────┴───────────────────┴───────────────────┘
            //
            bool isGr     = t.type==sstd_yaml::num_list || t_nx.type==sstd_yaml::num_hash; // check '>' case
            bool isGrOrEq = !isGr;                                                         // check '>=' case
            if((isGr     && hsc_next> hsc_curr) ||
               (isGrOrEq && hsc_next>=hsc_curr)    )
            {
                // --- debug info ---
                c.line_num_begin  = t.line_num_begin;
                c.line_num_end    = t.line_num_end;
                c.rawStr          = t.rawStr;
                // --- construct info ---
                c.ope             = sstd_yaml::ope_stack;
                c.hsc             = hsc_next;
                
                ret_vCmd.push_back(c);
            }
        }
    }
    
    return true;
}

bool _is_control_chars(const char c){
    return (c=='[' || c==']' || c=='{' || c=='}' || c==':' || c==',');
}
bool sstd_yaml::_split_quotes_by_control_chars(std::vector<std::string>& ret, const char* str, const uint str_len){
    bool is_escaped=false;
    bool in_d_quate=false; // double quate
    bool in_s_quate=false; // single quate
    std::string buf;
    uint i=0;
    while(i<str_len){ // r: read place
        if(str[i]=='\\'){ is_escaped=true; buf+=str[i]; ++i; if(i>=str_len){break;} }
        
        if(!is_escaped && !in_s_quate && str[i]=='"' ){ in_d_quate = !in_d_quate; }
        if(!is_escaped && !in_d_quate && str[i]=='\''){ in_s_quate = !in_s_quate; }
        
        if(!in_d_quate && !in_s_quate && (_is_control_chars(str[i]))){
            buf = sstd::strip(buf);
            if(buf.size()!=0){
                ret.push_back(buf);
                buf.clear();
            }
            ret.push_back(std::string(1, str[i])); // append a control char
            ++i;
        }else{
            buf += str[i];
            ++i;
        }
        
        is_escaped=false;
    }
    if(in_d_quate){ ret.clear(); return false; }
    if(in_s_quate){ ret.clear(); return false; }
    buf = sstd::strip(buf);
    if(buf.size()!=0){ ret.push_back(buf); }
    
    return true;
}
bool _get_hash_value(bool& is_null, std::string& ret_value, const std::vector<std::string>& v_cs, uint& i){
    if(i+3<v_cs.size() && v_cs[i+1][0]==':' && (v_cs[i+3][0]==',' || v_cs[i+3][0]=='}' || v_cs[i+3][0]==']')){
        // { "k1": "v1" }, { "k1": "v1", "k2": "v2" } or [ "k1": "v1" ] (<- Abbreviated of "[{ "k1": "v1" }]")
        ret_value = v_cs[i+2];
        is_null = false;
        i += 2;
        return true; // get value
    }else if(i+2<v_cs.size() && v_cs[i+1][0]==':' && (v_cs[i+2][0]=='}' || v_cs[i+2][0]==']' || v_cs[i+2][0]==',')){
        // { "k1": }, { "k1":, "k2" } or [ "k1": "v1" ] (<- Abbreviated of "[{ "k1": "v1" }]")
        is_null = true;
        i += 2;
        return true; // get null value
    }else if(i+1<v_cs.size() && (v_cs[i+1][0]=='}' || v_cs[i+1][0]==']' || v_cs[i+1][0]==',')){
        // { "k1" }, { "k1", "k2" } or [ "k1": "v1" ] (<- Abbreviated of "[{ "k1": "v1" }]")
        is_null = true;
        i += 1;
        return true; // get null value
    }

    // not get a string value (have a value of object)
    // { "k1" { "k2": }}
    return false;
}
bool _flow_style_str_to_obj(sstd::terp::var& var_out, const std::string& s_in){
    //sstd::printn(var_out.typeStr());
    //sstd::printn(s_in);
    std::vector<std::string> v_cs; // vector of commands and string
    if(!sstd_yaml::_split_quotes_by_control_chars(v_cs, s_in.c_str(), s_in.size())){ sstd::pdbg_err("_split_quotes_by_control_chars() is failed. Un-cloused quate.\n"); return false; }
    //sstd::printn(v_cs);
    
    std::vector<sstd::terp::var*> v_dst;
    v_dst.push_back( &var_out );
    
    for(uint i=0; i<v_cs.size(); ++i){
        //printf("\n\n");
        //sstd::printn(var_out);
        //sstd::printn(v_cs[i]);
        //sstd::printn(v_dst.size());
        if(v_dst.size()==0){ sstd::pdbg_err("broken pointer\n"); return false; }
        sstd::terp::var* pVar = v_dst[v_dst.size()-1];
        sstd::terp::var& var = *pVar;
        //if(v_hsc_lx.size()==0){ sstd::pdbg_err("v_hsc_lx is out of range\n"); return false; }
        //if(v_hsc_hx.size()==0){ sstd::pdbg_err("v_hsc_hx is out of range\n"); return false; }
        
        if(v_cs[i].size()==1 && _is_control_chars(v_cs[i][0])){
            switch(v_cs[i][0]){
            case '[': {
                if(var.typeNum()==sstd::num_null){
                    var = sstd::terp::list();
                }else if(var.typeNum()==sstd::num_vec_terp_var){
                    var.push_back( sstd::terp::list() );
                    v_dst.push_back( &(var[var.size()-1]) );
                }
            } break;
            case ']': {
                if(var.typeNum()==sstd::num_hash_terp_var){ v_dst.pop_back(); } // for [k: v] which is an abbreviated notation of [{k: v}]
                v_dst.pop_back();
            } break;
            case '{': {
                if(var.typeNum()==sstd::num_null){
                    var = sstd::terp::hash();
                }else if(var.typeNum()==sstd::num_vec_terp_var){
                    var.push_back( sstd::terp::hash() );
                    v_dst.push_back( &(var[var.size()-1]) );
                }
            } break;
            case '}': { v_dst.pop_back(); } break;
            case ':': {} break;
            case ',': {} break;
                //case ',': { if(var.typeNum()==sstd::num_vec_terp_var){v_dst.pop_back();} } break; // たぶんこれにしないと "[a,b,{k:v},c]" が落ちる
            default: { sstd::pdbg_err("Unexpected char\n"); return false; } break;
            }
        }else{
            switch(var.typeNum()){
            case sstd::num_vec_terp_var: {
                // list
                if(i+1<v_cs.size() && v_cs[i+1].size()==1 && v_cs[i+1][0]==':'){ // for [k: v] which is an abbreviated notation of [{k: v}]
                    var.push_back( sstd::terp::hash() );
                    v_dst.push_back( &(var[var.size()-1]) );
                    --i; continue;
                }
                var.push_back(v_cs[i]);
            } break;
            case sstd::num_hash_terp_var: {
                // hash
                bool is_null;
                std::string key = v_cs[i];
                std::string val;
                if(_get_hash_value(is_null, val, v_cs, i)){
                    if(!is_null){ var[ key.c_str() ] = _extract_quotes_value(sstd::strip_quotes(val.c_str()));
                    }   else    { var[ key.c_str() ]; }
                }else{
                    v_dst.push_back( &(var[key.c_str()]) );
                }
            } break;
            case sstd::num_null: {} break;
            default: { sstd::pdbg_err("Unexpected data type. Type: %s\n", sstd::typeNum2str(var.typeNum()).c_str()); sstd::printn(var); } break;
            }
        }
    }
    
    return true;
}
bool _construct_var(sstd::terp::var& ret_yml, const std::vector<struct sstd_yaml::command>& v_cmd){
    std::vector<sstd::terp::var*> v_dst;
    std::vector<uint> v_hsc_lx; // v: vector, hsc: head space count, _lx: list-index.
    std::vector<uint> v_hsc_hx; // v: vector, hsc: head space count. _hx: hash-index.
    v_dst.push_back(&ret_yml);
    v_hsc_lx.push_back(0);
    v_hsc_hx.push_back(0);
    
    for(uint i=0; i<v_cmd.size(); ++i){
        printf("\n\n--- begin cmd ---\n"); // for debug
        _print(v_cmd[i]);                  // for debug
        if(v_dst.size()==0){ sstd::pdbg_err("broken pointer\n"); return false; }
        sstd::terp::var* pVar = v_dst[v_dst.size()-1];
        sstd::terp::var& var = *pVar;
        if(v_hsc_lx.size()==0){ sstd::pdbg_err("v_hsc_lx is out of range\n"); return false; }
        if(v_hsc_hx.size()==0){ sstd::pdbg_err("v_hsc_hx is out of range\n"); return false; }
        uint hsc_base_lx = v_hsc_lx[v_hsc_lx.size()-1];
        uint hsc_base_hx = v_hsc_hx[v_hsc_hx.size()-1];
        
        // check indent
        switch(var.typeNum()){
        case sstd::num_vec_terp_var: {
            // list
            if(v_cmd[i].hsc_lx > hsc_base_lx){
                v_hsc_lx.push_back(v_cmd[i].hsc_lx);
                --i;
                continue;
            }else if(v_cmd[i].hsc_lx < hsc_base_lx){
                v_dst.pop_back();
                v_hsc_lx.pop_back();
                --i;
                continue;
            }
        } break;
        case sstd::num_hash_terp_var: {
            // hash
            if(v_cmd[i].hsc_hx > hsc_base_hx){
                v_hsc_hx.push_back(v_cmd[i].hsc_hx);
                --i;
                continue;
            }else if(v_cmd[i].hsc_hx < hsc_base_hx){
                v_dst.pop_back();
                v_hsc_hx.pop_back();
                --i;
                continue;
            }else if(v_cmd[i].type==sstd_yaml::num_list_and_hash){
                v_dst.pop_back();
                v_hsc_hx.pop_back();
                --i;
                continue;
            }
        } break;
        case sstd::num_null: {} break;
        default: { sstd::pdbg_err("Unexpected data type\n"); } break;
        }

        // set dst type (if dst is sstd::num_null)
        if(var.typeNum()==sstd::num_null){
            switch(v_cmd[i].type){
            case sstd_yaml::num_str:           {                           } break;
            case sstd_yaml::num_list:          { var = sstd::terp::list(); } break;
            case sstd_yaml::num_list_and_hash: { var = sstd::terp::list(); } break;
            case sstd_yaml::num_hash:          { var = sstd::terp::hash(); } break;
//            case NUM_FORMAT:        { sstd::pdbg_err("in NUM_FORMAT\n");                          } break;
            default: { sstd::pdbg_err("Unexpected data type\n"); return false; } break;
            }
        }

        // set dst
        bool needs_to_set_dst_list = !(v_cmd[i].val1.size()>=1 || v_cmd[i].val1_use_quotes);
        if(v_cmd[i].type==sstd_yaml::num_list && needs_to_set_dst_list){
            var.push_back( sstd::terp::list() );
            v_dst.push_back( &(var[var.size()-1]) );
            if(v_cmd[i].format==sstd_yaml::num_block_style_base){ continue; }
        }
        bool needs_to_set_dst_hash = !(v_cmd[i].val2.size()>=1 || v_cmd[i].val2_use_quotes);
        if((v_cmd[i].format + v_cmd[i].type)==sstd_yaml::num_block_style_base + sstd_yaml::num_hash && needs_to_set_dst_hash){
            v_dst.push_back( &(var[v_cmd[i].val1.c_str()]) );
            if(v_cmd[i].format==sstd_yaml::num_block_style_base){ continue; }
        }

        // set value
        //sstd::printn(var);
        //sstd::printn(v_cmd[i].format);
        //sstd::printn(v_cmd[i].type);
        switch(v_cmd[i].format + v_cmd[i].type){
        case sstd_yaml::num_block_style_base + sstd_yaml::num_str: {
            if(var.typeNum()!=sstd::num_null){ sstd::pdbg_err("OverWritting the existing data. (String data type can only take one data.)\n"); break; }
            var = v_cmd[i].val1.c_str();
        } break;
        case sstd_yaml::num_block_style_base + sstd_yaml::num_list: {
            var.push_back( v_cmd[i].val1.c_str() );
        } break;
        case sstd_yaml::num_block_style_base + sstd_yaml::num_list_and_hash: {
            var.push_back( sstd::terp::hash() );
            v_dst.push_back( &(var[var.size()-1]) );
        } break;
        case sstd_yaml::num_block_style_base + sstd_yaml::num_hash: {
            var[ v_cmd[i].val1.c_str() ] = v_cmd[i].val2.c_str();
        } break;
        case sstd_yaml::num_flow_style_base + sstd_yaml::num_str:
        case sstd_yaml::num_flow_style_base + sstd_yaml::num_list:
        case sstd_yaml::num_flow_style_base + sstd_yaml::num_hash: {
            if(!_flow_style_str_to_obj(var, v_cmd[i].val1.c_str())){ sstd::pdbg_err("Converting flow style string to object is failed."); return false; }
        } break;
        case sstd_yaml::num_flow_style_base + sstd_yaml::num_list_and_hash: {
            if(!_flow_style_str_to_obj(var[ v_cmd[i].val1.c_str() ], v_cmd[i].val2.c_str())){ sstd::pdbg_err("Converting flow style string to object is failed."); return false; }
        } break;
        default: { sstd::pdbg_err("ERROR\n"); } break;
        }
        
        sstd::printn(var); // for debug
        sstd::printn(ret_yml); // for debug
    }

    return true;
}
bool _construct_var_v2(sstd::terp::var& ret_yml, const std::vector<struct sstd_yaml::command_v2>& v_cmd){
    std::vector<sstd::terp::var*> v_dst;    // v: vector, _dst: destination. An address stack for sstd_yaml::ope_alloc (follows the YAML indent)
    std::vector<sstd::terp::var*> v_dst_cr; // v: vector, _dst: destination address, _cr: current. An address stack for sstd_yaml::ope_stack or sstd_yaml::ope_assign.
    std::vector<uint> v_hsc; // v: vector, hsc: head space count
    v_dst.push_back(&ret_yml);
    v_dst_cr.push_back(&ret_yml);
    v_hsc.push_back(0);
    
    for(uint i=0; i<v_cmd.size(); ++i){
//        printf("\n\n--- begin token ---\n"); // for debug
        if(v_dst.size()==0){ sstd::pdbg_err("broken pointer\n"); return false; }
        const struct sstd_yaml::command_v2& cmd = v_cmd[i];

        if(cmd.ope==sstd_yaml::ope_alloc){
            // Inits v_dst_cr if the v_cmd is the beginning of the `sstd_yaml::ope_alloc` operation.
            v_dst_cr.clear();
            if(v_dst.size()==0){ sstd::pdbg_err("broken pointer\n"); return false; }
            v_dst_cr.push_back(v_dst[v_dst.size()-1]);
        }
        sstd::terp::var* pVar = v_dst_cr[v_dst_cr.size()-1];
        sstd::terp::var& var = *pVar;
        if(v_hsc.size()==0){ sstd::pdbg_err("v_hsc is out of range\n"); return false; }
        uint hsc_base = v_hsc[v_hsc.size()-1];
//        sstd::printn(v_dst);              // for debug
//        sstd::printn(v_dst_cr);              // for debug
//        sstd::printn(v_hsc);              // for debug
//        sstd::printn(cmd.hsc);              // for debug
//        sstd::printn(hsc_base);              // for debug
        
//        sstd::printn(i);                     // for debug
//        sstd::printn(v_cmd[i]);              // for debug

        // checking the stack command
        if(cmd.ope==sstd_yaml::ope_stack){
            if(v_dst_cr.size()==0){ sstd::pdbg_err("broken pointer\n"); return false; }
            v_dst.push_back(v_dst_cr[v_dst_cr.size()-1]);
            v_hsc.push_back(cmd.hsc);
            continue;
        }
        
        // checking the YAML indent
        if(cmd.hsc < hsc_base){
            v_dst.pop_back();
            v_hsc.pop_back();
            --i;
            continue; // continue for multiple escape
        }
        
        // setting the value or allocate dst address
        if(cmd.ope==sstd_yaml::ope_assign){
            if(var.typeNum()!=sstd::num_null){ sstd::pdbg_err("OverWritting the existing data.\n"); return false; }
            var = cmd.val;
        }else if(cmd.ope==sstd_yaml::ope_alloc){
            if(var.typeNum()==sstd::num_null){
                switch(cmd.type){
                case sstd_yaml::num_list: { var = sstd::terp::list(); } break;
                case sstd_yaml::num_hash: { var = sstd::terp::hash(); } break;
                default: { sstd::pdbg_err("Unexpected data type\n"); return false; } break;
                }
            }
            
            switch(cmd.type){
            case sstd_yaml::num_list: {
                var.push_back();
                v_dst_cr.push_back(&var[var.size()-1]);
            } break;
            case sstd_yaml::num_hash: {
                auto itr = var.find(cmd.val);
                if(itr!=var.end()){ sstd::pdbg_err("Detecting the duplicated hash key.\n"); return false; }
                v_dst_cr.push_back(&var[cmd.val]);
            } break;
            default: { sstd::pdbg_err("Unexpected data type\n"); return false; } break;
            }
        }else{
            sstd::pdbg_err("Unexpected data type\n"); return false;
        }
        
//        sstd::printn(var); // for debug
//        sstd::printn(ret_yml); // for debug
    }
    return true;
}

//-----------------------------------------------------------------------------------------------------------------------------------------------
// str2token section

bool sstd_yaml::_splitByLine_quotes_brackets(std::vector<std::string>& ret, const char* str){ // token ベースに書き換えたら消す
    
    bool is_escaped=false;
    bool in_d_quate=false; // double quate
    bool in_s_quate=false; // single quate
    std::string buf;
    
    int num_of_square_brackets=0; // []
    int num_of_curly_brackets=0;  // {}
    for(uint r=0; str[r]!=0;){ // r: read place
        buf.clear();
        for(; str[r]!='\0'; ++r){
            if(str[r]=='\\'){ is_escaped=true; buf+=str[r]; ++r; if(str[r]=='\0'){break;} }
            
            if(!is_escaped && !in_s_quate && str[r]=='"' ){ in_d_quate = !in_d_quate; }
            if(!is_escaped && !in_d_quate && str[r]=='\''){ in_s_quate = !in_s_quate; }
            
            if(!in_d_quate && !in_s_quate && str[r]=='['){ ++num_of_square_brackets; }
            if(!in_d_quate && !in_s_quate && str[r]==']'){ --num_of_square_brackets; }
            
            if(!in_d_quate && !in_s_quate && str[r]=='{'){ ++num_of_curly_brackets; }
            if(!in_d_quate && !in_s_quate && str[r]=='}'){ --num_of_curly_brackets; }
            
            if(!in_d_quate && !in_s_quate && num_of_square_brackets==0 && num_of_curly_brackets==0 && str[r]==0x0A                  ){ r+=1; break; } // Uinx ("\n")
            if(!in_d_quate && !in_s_quate && num_of_square_brackets==0 && num_of_curly_brackets==0 && str[r]==0x0D && str[r+1]==0x0A){ r+=2; break; } // Windows ("\r\n")
            buf += str[r];
            
            is_escaped=false;
        }
        ret.push_back(std::move(buf));
    }
    if(in_d_quate){ ret.clear(); return false; }
    if(in_s_quate){ ret.clear(); return false; }
    if(num_of_square_brackets){ ret.clear(); return false; }
    if(num_of_curly_brackets ){ ret.clear(); return false; }
    
    return true;
}
bool sstd_yaml::_splitByLine_quotes_brackets(std::vector<std::string>& ret, const std::string& str){ // token ベースに書き換えたら消す
    return sstd_yaml::_splitByLine_quotes_brackets(ret, str.c_str());
}

//---

bool _is_flow(const std::string& subt){
    return subt.size()>=1 && (subt[0]=='[' || subt[0]=='{');
}

bool sstd_yaml::_str2token(std::vector<sstd_yaml::token>& ret, const char* str){
    // Parse rule of YAML string
    // 
    // Rule1. For default, Block-Style-String ("- ", ": ") and Line-Break-Codes ('\n', "\r\n") are
    //        treated as controle-charactors ("- ", ": ", '\n', "\r\n").
    //        String are splitted by the controle-characotrs
    //        if the target string is out of quates ("", '') and brackets ([], {}) ranges.
    //        / デフォルトでは，Block-Style の文字列 ("- ", ": ") と改行コード ('\n', "\r\n") を制御文字列として扱います．
    //          引用符 ("", '') と括弧 ([], {}) の範囲外では，文字列は制御文字列で分割されます．
    //
    // Rule2. Skipping the splitting process using controle-charactors ("- ", ": ", '\n', "\r\n")
    //        if the string in quates range.
    //        / 文字列がクォーテーションで括られている場合は，
    //          制御文字 ("- ", ": ", '\n', "\r\n") での文字列の分割を停止します．
    // 
    // Rule3. Skipping the splitting process using controle-charactors ("- ", ": ", '\n', "\r\n")
    //        after detecting the subtoken is beginning from the beginning of brackets ([, {) for flow-style-notation.
    //        / Subtoken が Flow-Style 表記の開始を示す括弧 ([, {) で開始される場合は，
    //          制御文字 ("- ", ": ", '\n', "\r\n") での文字列の分割を停止します．
    // 
    // Rule4. Detecting comments by "#" (in head of the line) or " #" notation
    //        / コメントは "#" (行の先頭) または " #" 表記で判定します
    // 
    // Rule5. Using line break code ('\n', "\r\n") as a control charactor
    //        excepting the case of subtoken begin from multi-line notation charactor ('|').
    //        / 改行コード ('\n', "\r\n") は，制御文字として扱います．
    //          ただし，subtoken がマルチライン表記を示す文字 ('|') から始まる場合を除きます．
    
    uint line_num = 1; // line number is 1 indexed

    // for quotes ("", '')
    bool is_escaped=false; // \", \'
    bool in_d_quate=false; // double quate ("")
    bool in_s_quate=false; // single quate ('')

    // for multiple line ('|')
    bool is_mult=false; // is multi line type '|'
    sstd_yaml::token tmp_prev;
//    std::string subt_prev;
    
    int cnt=0; // for debug
    
    for(uint r=0; str[r]!=0;){ // r: read place
        sstd_yaml::token tmp;
        tmp.line_num_begin = line_num;
        
        std::string subt; // subtoken
        
        // for type
        bool is_list=false; // is list type "- "
        bool is_hash=false; // is hash type "k: v"
        bool is_flow=false; // is flow style "[{k: v}]"
        //bool is_mult=false; // is multiple line '|'
        bool is_in_token=false;

        int num_of_square_brackets=0; // []
        int num_of_curly_brackets=0;  // {}

        // for multiple line
//        if(is_mult){
//            std::swap(tmp, tmp_prev);
//            std::swap(subt, subt_prev);
//        }
        is_mult=false;
        bool is_mult_end=false;
        uint hsc_lx_mult=0;
        //uint hsc_hx_mult=0;
        uint r_prev_line_end=0;
        
        for(;;++r){
            //printf("---\n");
            //sstd::printn(r);
            //sstd::printn(str[r]);
            if(str[r]=='\\'){ is_escaped=true; tmp.rawStr+=str[r]; ++r; }
//            if(str[r]=='\n'){ ++line_num; break; }
            if(str[r]=='\0'){ ++line_num; break; }
            if(str[r]!=' '){ is_in_token=true; }
            if(str[r]==' ' && !is_in_token){ ++tmp.hsc_lx; ++tmp.hsc_hx; }
            
            if(!is_escaped && !in_s_quate && str[r]=='"' ){ in_d_quate = !in_d_quate; }
            if(!is_escaped && !in_d_quate && str[r]=='\''){ in_s_quate = !in_s_quate; }

            if(!in_d_quate && !in_s_quate){
                if((subt.size()==0 && str[r]=='#') || (str[r]==' ' && str[r+1]=='#')){
                    tmp.rawStr+=str[r]; ++r;
                    while(str[r]!='\0' && str[r]!='\n' && str[r]!='\r'){ tmp.rawStr+=str[r]; ++r; } // skip comments
                }
                
                is_flow = _is_flow(subt+str[r]);
                if(!is_flow && !is_mult){
                    // Block Style
                    if(str[r]=='|'){ is_mult=true; subt+=str[r]; hsc_lx_mult=tmp.hsc_lx; tmp.rawStr+=str[r]; continue; }
                    
                    // for Windows
                    if(str[r]=='-' && str[r+1]=='\r'){                                        subt.clear(); is_list=true; ++tmp.list_type_cnt; tmp.rawStr+=str[r]; continue; }
                    if(str[r]==':' && str[r+1]=='\r'){ tmp.val1=std::move(sstd::strip(subt)); subt.clear(); is_hash=true;                      tmp.rawStr+=str[r]; continue; }
                    
                    // for Unix
                    if(str[r]=='-' && str[r+1]=='\n'){                                        subt.clear(); is_list=true; ++tmp.list_type_cnt; tmp.rawStr+=str[r]; continue; }
                    if(str[r]==':' && str[r+1]=='\n'){ tmp.val1=std::move(sstd::strip(subt)); subt.clear(); is_hash=true;                      tmp.rawStr+=str[r]; continue; }
                    
                    // the other case
                    if(str[r]=='-' && str[r+1]==' '){                                        subt.clear(); is_list=true; ++tmp.list_type_cnt; tmp.rawStr+=str[r]; ++r; tmp.rawStr+=str[r]; continue; }
                    if(str[r]==':' && str[r+1]==' '){ tmp.val1=std::move(sstd::strip(subt)); subt.clear(); is_hash=true;                      tmp.rawStr+=str[r]; ++r; tmp.rawStr+=str[r]; continue; }
                }else if(!is_mult){
                    // Flow Style
                    if(str[r]=='['){ ++num_of_square_brackets; }
                    if(str[r]==']'){ --num_of_square_brackets; }
                    if(str[r]=='{'){ ++num_of_curly_brackets; }
                    if(str[r]=='}'){ --num_of_curly_brackets; }
                }else{
                    // multi line

                    // 処理のルール
                    // X 1. 行単位で処理する．(処理終了時に巻き戻せるように)
                    // 1. 処理終了時に巻き戻せるように，前行末尾の位置を r_prev_line_end に記録する．
                    
                    // X 2. 処理の終わりを検知したら，超過読み込み分を巻き戻す．
                    // 2. 処理の終わりを検知したら，raw と subst を巻き戻し訂正する

                    // まずは簡易実装で済ます．効率はあとから．
                    bool is_break=false;
                    if(str[r]=='-' && str[r+1]=='\r'){ is_break=true; }
                    if(str[r]==':' && str[r+1]=='\r'){ is_break=true; }
                    if(str[r]=='-' && str[r+1]=='\n'){ is_break=true; }
                    if(str[r]==':' && str[r+1]=='\n'){ is_break=true; }
                    if(str[r]=='-' && str[r+1]==' ' ){ is_break=true; }
                    if(str[r]=='-' && str[r+1]==' ' ){ is_break=true; }
                    if(is_break && tmp.hsc_lx <= hsc_lx_mult){
                        is_mult_end=true;
                    }
                }
            }
            tmp.rawStr += str[r];
            subt       += str[r];
            
            // Checking the token break
            if(is_mult_end){
                tmp.rawStr.erase(tmp.rawStr.size()-(r-r_prev_line_end));
                subt.erase(subt.size()-(r-r_prev_line_end));
                r = r_prev_line_end;
                // revert "rawStr" and "subt".
                //std::copy(str.begin()+r_prev_line_end+1, str.begin()+r+1, tmp_prev.rawStr.begin());
                //std::copy(,, subt_prev.begin());
                        
                //tmp.rawStr.erase();
                //subt = ;
                ++r;
                break;
            }
            if(str[r]=='\n'){ // Uinx ("\n")
                ++line_num;
                if(!is_flow && !is_mult && !is_escaped && !in_d_quate){ ++r; break; } 
                if( is_flow             && num_of_square_brackets==0 && num_of_curly_brackets==0){ ++r; break; }
                if(             is_mult ){ tmp.hsc_hx=0; tmp.hsc_lx=0; r_prev_line_end=r; continue; }
                
            }else if(str[r]=='\r' && str[r+1]=='\n'){ // Windows ("\r\n")
                ++line_num; ++r;
                if(!is_flow && !is_mult && !is_escaped && !in_d_quate){ r+=2; break; } 
                if( is_flow             && num_of_square_brackets==0 && num_of_curly_brackets==0){ r+=2; break; }
                if(             is_mult ){ tmp.hsc_hx=0; tmp.hsc_lx=0; r_prev_line_end=r; tmp.rawStr+=str[r]; continue; }
            }
            
            // init
            is_escaped = false;
        }
        tmp.line_num_end = std::max((int)tmp.line_num_begin, ((int)line_num)-1);

        if(!is_hash){ tmp.val1=std::move(sstd::strip(subt));
        }    else   { tmp.val2=std::move(sstd::strip(subt)); }
        
        if(is_list){ tmp.type += sstd_yaml::num_list; tmp.hsc_hx+=2; }
        if(is_hash){ tmp.type += sstd_yaml::num_hash; }
        if(is_flow){ tmp.format = sstd_yaml::num_flow_style_base; }

        // remove line break codes ('\n', "\r\n") at the tail of token
        if(!is_mult){
            tmp.val1 = sstd::rstrip(tmp.val1, '\n'); // NOTE: "\r\n" is not supported yet
            tmp.val2 = sstd::rstrip(tmp.val2, '\n'); // NOTE: "\r\n" is not supported yet
        }
        
        // remove Quates ('', "")
        bool v1_dq, v1_sq, v2_dq, v2_sq;
        tmp.val1            = sstd::strip_quotes(v1_sq, v1_dq, tmp.val1);
        tmp.val2            = sstd::strip_quotes(v2_sq, v2_dq, tmp.val2);
        tmp.val1_use_quotes = ( v1_dq || v1_sq );
        tmp.val2_use_quotes = ( v2_dq || v2_sq );
        //if(tmp.val1_use_quotes || is_flow){ tmp.val1 = _extract_quotes_value(tmp.val1); }
        if(tmp.val1_use_quotes){ tmp.val1 = _extract_quotes_value(tmp.val1); }
        if(tmp.val2_use_quotes){ tmp.val2 = _extract_quotes_value(tmp.val2); }
        //if(is_mult){ tmp.val1 = _normalize_the_mult_value(hsc_lx_mult, tmp.val1); }
        
        if(tmp.val1.size()==0 && !tmp.val1_use_quotes &&
           tmp.val2.size()==0 && !tmp.val2_use_quotes &&
           tmp.type==sstd_yaml::num_str                  ){ continue; }
        
        // set hasValue
        tmp.hasValue=false;
        switch(tmp.type){
        case sstd_yaml::num_str:           { tmp.hasValue=true; } break;
        case sstd_yaml::num_list:          { if(tmp.val1_use_quotes||tmp.val1.size()>=1){tmp.hasValue=true;} } break; // check the value is NOT NULL
        case sstd_yaml::num_list_and_hash:
        case sstd_yaml::num_hash:          { if(tmp.val2_use_quotes||tmp.val2.size()>=1){tmp.hasValue=true;} } break; // check the value is NOT NULL
        default: { sstd::pdbg_err("Unexpected data type\n"); return false; } break;
        }
        
        ret.push_back(std::move(tmp));
    }
    if(in_d_quate){ ret.clear(); return false; }
    if(in_s_quate){ ret.clear(); return false; }
    
    return true;
}
bool sstd_yaml::_str2token(std::vector<sstd_yaml::token>& ret, const std::string& str){
    return sstd_yaml::_str2token(ret, str.c_str());
}

//-----------------------------------------------------------------------------------------------------------------------------------------------
// YAML load section

bool sstd::yaml_load(sstd::terp::var& ret_yml, const char* s){
    bool tf = true;
    
    std::vector<sstd_yaml::token> v_token; if(!sstd_yaml::_str2token(v_token, s)){ sstd::pdbg_err("single or double quatation is not closed\n"); return false; } // v: vector, ls: line string
    sstd::printn(v_token);
    std::vector<struct sstd_yaml::command_v2> v_cmd; if(!sstd_yaml::_token2cmd(v_cmd, v_token)){ return false; }
    if(!_construct_var_v2(ret_yml, v_cmd)){ return false; }
    
    return tf;
}
bool sstd::yaml_load(sstd::terp::var& ret_yml, const std::string& s){ return sstd::yaml_load(ret_yml, s.c_str()); }

//---

std::vector<std::vector<std::string>> _split_by_separator(const std::vector<std::string>& ls){
    std::vector<std::vector<std::string>> v_ls;

    std::vector<std::string> ls_tmp;
    for(uint i=0; i<ls.size(); ++i){
        std::string s = ls[i];
        s = _rm_comment(s); // s = _rm_comment_quotes(s); に置き換える
        if(s=="---"){ // detect the separator
            v_ls.push_back(std::move(ls_tmp));
            ls_tmp.clear();
            continue;
        }
        
        ls_tmp.push_back(std::move(ls[i]));
    }
    v_ls.push_back(std::move(ls_tmp));
    
    return v_ls;
}
bool sstd::yaml_load_all(std::vector<sstd::terp::var>& ret_vYml, const        char* s){
    std::vector<std::string> ls; if(!sstd_yaml::_splitByLine_quotes_brackets(ls, s)){ sstd::pdbg_err("double quatation is not closed\n"); return false; } // v: vector, ls: line string
    std::vector<std::vector<std::string>> v_ls = _split_by_separator(ls);

    uint base_idx=0;
    for(uint i=0; i<v_ls.size(); ++i){
        sstd::terp::var ret_yml;
        std::vector<struct sstd_yaml::command> v_cmd; if(!_parse_yaml(v_cmd, v_ls[i], base_idx)){ return false; }
        if(!_construct_var(ret_yml, v_cmd)){ return false; }
        
        ret_vYml.push_back(std::move(ret_yml));
        base_idx += v_ls[i].size() + 1;
    }
    
    return true;
}
bool sstd::yaml_load_all(std::vector<sstd::terp::var>& ret_vYml, const std::string& s){ return sstd::yaml_load_all(ret_vYml, s.c_str()); }

//---

bool sstd::yaml_load(sstd::terp::var& ret_yml, sstd::file& fp){
    size_t size = fp.fsize();
    std::vector<char> raw(size+1, 0);
    if(fp.fread((uchar*)&raw[0], sizeof(char), size)!=size){
        sstd::pdbg_err("fread was failed.\n");
        return false;
    }
    //printf("&raw[0] = %s\n", &raw[0]);
    
    if(!sstd::yaml_load(ret_yml, (const char*)&raw[0])){ return false; }
    
    return true;
}
bool sstd::yaml_load_all(std::vector<sstd::terp::var>& ret_vYml, sstd::file& fp){
    size_t size = fp.fsize();
    std::vector<char> raw(size+1, 0);
    if(fp.fread((uchar*)&raw[0], sizeof(char), size)!=size){
        sstd::pdbg_err("fread was failed.\n");
        return false;
    }
    //printf("&raw[0] = %s\n", &raw[0]);
    
    if(!sstd::yaml_load_all(ret_vYml, (const char*)&raw[0])){ return false; }
    
    return true;
}

//-----------------------------------------------------------------------------------------------------------------------------------------------

